import random
import json
import progress

ITERATIONS = 1000


def main():
    # Open the json with the assigned ball combos for the teams. This is generated ahead of time by another script
    with open('combos.json', 'rb') as f:
        teams = json.load(f)

    # Combines all the possible combinations into a pool to be referenced by the random number selection
    combo_pool = []
    for key, combos in teams.items():
        combo_pool.extend(combos)

    # Load the numbers generated by random.org to use as list indexes for drawing combos from the combo_pool. It adds a
    # second layer of randomness beyond just the random module. There are 10000 random numbers between 0 and 104
    with open('random.txt', 'rb') as f:
        random_num_pool = list(f.read().split())

    # Create a dict to store the results of the iterations to be used later for calculating the probability of each
    # owner getting a given draft slot
    results = {x: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0} for x in teams.keys()}

    # Init the progress bar and start iterating through the number of iterations specified

    bar = progress.Bar(ITERATIONS)
    for x in range(1, ITERATIONS):
        # Start each iteration by resetting the variables used, creating temp versions of the random numbers and teams
        # We shuffle the random number pool and then clone it. The pool is used as the list index to draw from the
        # combo_pool

        teams_still_in_lottery = dict(teams)
        random.shuffle(random_num_pool)
        iterations_random_numbers = list(random_num_pool)
        selected = []

        while teams_still_in_lottery:
            # "Draw" a number from the combo pool and if it belongs to a team that hasn't already been picked continue
            # If there is just one team left, don't bother with the checks and move on to the next round
            if len(teams_still_in_lottery) == 1:
                results[teams_still_in_lottery.keys()[0]][12] += 1
                break
            else:
                draw = combo_pool[int(iterations_random_numbers.pop())]

            if draw not in selected:
                # Iterate through the teams still left in the draft and find who had the combo that was drawn
                # Add all their combos to the selected list so they are not drawn again. Then delete them from the
                # still_in_lottery dict and update the results dict with what round they got for a pick

                for team, team_numbers in teams.items():
                    if draw in team_numbers:
                        selected.extend(teams[team])
                        del teams_still_in_lottery[team]
                        draft_round = 12 - len(teams_still_in_lottery)
                        results[team][draft_round] += 1
        bar.update(x)

    print '\n', json.dumps(results, separators=[',', ':'], indent=2)

    # with open('output.csv', 'wb') as f:
    #     fieldnames = ['name', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    #     writer = csv.DictWriter(f, fieldnames=fieldnames)
    #     writer.writerows(writable_results)
    #
    # for team, results in results.items():
    #     writable_results.append(results)
    #
    #     for k, v in results.items():
    #         print "\n{}'s Results".format(k)
    #         print '-' * 15
    #         ordered = OrderedDict(sorted(v.items()))
    #         for key, value in ordered.iteritems():
    #             try:
    #                 tot = float(value)
    #                 pct = tot / float(ITERATIONS) * 100
    #                 print "Round {} - {}%".format(key, pct)
    #             except ValueError:
    #                 pass

if __name__ == '__main__':
    main()
